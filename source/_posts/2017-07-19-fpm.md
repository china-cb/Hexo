---
title:  "简聊CGI,FastCGI,PHP-CGI,PHP-FPM之间的关系"
date: 2017-07-19  12:00:00
updated: 2017-07-19 12:00:00
comments: true
categories: PHP
tags:
    - PHP
    - watch
---

## 概述
`FPM(FastCGI Process Manager)`是`PHP FastCGI`运行模式的一个进程管理器，从它的定义可以看出，`FPM`的核心功能是进程管理，那么它用来管理什么进程呢？这个问题就需要从`FastCGI`说起了。
> 你(`PHP`)去和爱斯基摩人(`web`服务器，如 `Apache`、`Nginx`)谈生意.你说中文(`PHP`代码)，他说爱斯基摩语(`C`代码)，互相听不懂，怎么办？那就都把各自说的话转换成英语(`FastCGI` 协议)吧。
怎么转换呢？你就要使用一个翻译机(`PHP-FPM`) (当然对方也有一个翻译机，那个是他自带的)
我们这个翻译机是最新型的，老式的那个（`PHP-CGI`）被淘汰了。不过它(`PHP-FPM`)只有年轻人（`Linux`系统）会用，老头子们（`Windows`系统）不会摆弄它，只好继续用老式的那个。
 <!-- more -->
#### `CGI`是干嘛的？
**`CGI`是为了保证`web server`传递过来的数据是标准格式的，方便`CGI`程序的编写者.**
* `web server`（比如说`nginx`）只是内容的分发者。比如，如果请求/index.html，那么`web server`会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。好了，如果现在请求的是/index.php，根据配置文件，`nginx`知道这个不是静态文件，需要去找PHP解析器来处理，那么他会把这个请求简单处理后交给PHP解析器。`Nginx`会传哪些数据给PHP解析器呢？url要有吧，查询字符串也得有吧，POST数据也要有，HTTP header不能少吧，好的，`CGI`就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。仔细想想，你在PHP代码中使用的用户从哪里来的。
* 当`web server`收到/index.php这个请求后，会启动对应的`CGI`程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定`CGI`规定的格式返回处理后的结果，退出进程。`web server`再把结果返回给浏览器。

#### `CGI`是个协议，跟进程什么的没关系。那fastcgi又是什么呢？
**Fastcgi是用来提高`CGI`程序性能的。**
* 提高性能，那么`CGI`程序的性能问题在哪呢？"PHP解析器会解析php.ini文件，初始化执行环境"，就是这里了。标准的`CGI`对每个请求都会执行这些步骤（不闲累啊！启动进程很累的说！），所以处理每个时间的时间会比较长。这明显不合理嘛！那么Fastcgi是怎么做的呢？首先，Fastcgi会先启一个master，解析配置文件，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是fastcgi的对进程的管理。

#### `PHP-FPM`是什么呢？
**`PHP-FPM`(`FastCGI` Process Manager：`FastCGI`进程管理器)对于PHP 5.3.3之前的php来说，是一个补丁包[1]  ，旨在将`FastCGI`进程管理整合进PHP包中。如果你使用的是PHP5.3.3之前的PHP的话，就必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。**
* 大家都知道，PHP的解释器是php-cgi。php-cgi只是个`CGI`程序，他自己本身只能解析请求，返回结果，不会进程管理（皇上，臣妾真的做不到啊！）所以就出现了一些能够调度php-cgi进程的程序，比如说由lighthttpd分离出来的spawn-fcgi。好了`PHP-FPM`也是这么个东东，在长时间的发展后，逐渐得到了大家的认可（要知道，前几年大家可是抱怨`PHP-FPM`稳定性太差的），也越来越流行。

#### `FastCGI`的不足?
**因为是多进程，所以比`CGI`多线程消耗更多的服务器内存，PHP-CGI解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。**

* `Nginx` 0.8.46+PHP 5.2.14(`FastCGI`)服务器在3万并发连接下，开启的10个`Nginx`进程消耗150M内存（15M*10=150M），开启的64个php-cgi进程消耗1280M内存（20M*64=1280M），加上系统自身消耗的内存，总共消耗不到2GB内存。如果服务器内存较小，完全可以只开启25个php-cgi进程，这样php-cgi消耗的总内存数才500M。
上面的数据摘自`Nginx` 0.8.x + PHP 5.2.13(`FastCGI`)搭建胜过Apache十倍的Web服务器(第6版)。

#### `PHP-CGI`的不足?
* php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启。
* 直接杀死php-cgi进程，php就不能运行了。(`PHP-FPM`和Spawn-FCGI就没有这个问题，守护进程会平滑从新生成新的子进程。）
